<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[博客迁址公告]]></title>
    <url>%2F%E9%9A%8F%E8%AE%B0%2F%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%85%AC%E5%91%8A.html</url>
    <content type="text"><![CDATA[公告 为方便博客内容的管理，今后本人的博客内容优先在简书网站Jacknolfskin更新，该博客不作主要维护，但会留作简书博客备份，因此不会第一时间更新内容，多谢大家一直的关注和支持，欢迎移步做客！]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeanFactory和ApplicationContext的区别]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%2FSpring%E4%B8%ADBeanFactory%E5%92%8CApplicationContext%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[1、国际化 BeanFactory是不支持国际化功能的，因为BeanFactory没有扩展Spring中MessageResource接口。相反，由于ApplicationContext扩展了MessageResource接口，因而具有消息处理的能力(i18N) 2、强大的事件机制(Event) 基本上牵涉到事件(Event)方面的设计，就离不开观察者模式，ApplicationContext的事件机制主要通过ApplicationEvent和ApplicationListener这两个接口来提供的，和java swing中的事件机制一样。即当ApplicationContext中发布一个事件的时，所有扩展了ApplicationListener的Bean都将会接受到这个事件，并进行相应的处理。 3、底层资源的访问 ApplicationContext扩展了ResourceLoader(资源加载器)接口，从而可以用来加载多个Resource，而BeanFactory是没有扩展ResourceLoader 4、对Web应用的支持 与BeanFactory通常以编程的方式被创建不同的是，ApplicationContext能以声明的方式创建，如使用ContextLoader。当然你也可以使用ApplicationContext的实现之一来以编程的方式创建ApplicationContext实例 。 5、延迟加载1).BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，这样，我们就不能发现一些存在的spring的配置问题。而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误。 2).BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册 可以看到，ApplicationContext继承了BeanFactory，BeanFactory是Spring中比较原始的Factory，它不支持AOP、Web等Spring插件，而ApplicationContext不仅包含了BeanFactory的所有功能，还支持Spring的各种插件，还以一种面向框架的方式工作以及对上下文进行分层和实现继承。BeanFactory是Spring框架的基础设施，面向Spring本身；而ApplicationContext面向使用Spring的开发者，相比BeanFactory提供了更多面向实际应用的功能，几乎所有场合都可以直接使用ApplicationContext而不是底层的BeanFactory]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>BeanFactory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo + NexT 搭建静态博客]]></title>
    <url>%2F%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE%2F%E4%BD%BF%E7%94%A8Hexo%2BNextT%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[前言Github 为广大开发者提供了一个非常好的平台，不仅是代码的开源，同时 Github 还提供了开发者可以在 Github 上建立自己的站点（GithubPage）的一个非常有意思的功能。这个功能的局限是只能创建静态的网站，那么我们可以使用一些工具来快速创建这一网站。本文旨在帮助刚接触 Github 新手，想利用 Github 来创建自己的站点、个人博客等。大神可以忽视(:з」∠)。 准备你需要在 Github 上创建一个属于自己的账户，然后新建一个仓库（new repository），并命名为 YourSiteName.github.io/com，此时 Github 会帮助你初始化一个静态网页，你可以根据自己的喜好选择一些模版（这都不是重点），接着尝试访问下你所建的站点，成功后就可以开始动工了。 关于Hexo A fast, simple &amp; powerful blog framework快速，简单而高效的静态博客框架 关于NexT NexT is built for easily use with elegant appearance. First things first, always keep things simpleNexT 主旨在于简洁优雅且易于使用，所以首先要尽量确保 NexT 的简洁易用性。 这是一个扩展主题，由 iissnan 开发，精于心，简于形的理念。 参考: Deployment]]></content>
      <categories>
        <category>网站搭建</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>博客建设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解线程池]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</url>
    <content type="text"><![CDATA[线程池概述 什么是线程池 为什么使用线程池 线程池的优势 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 第二：提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。 创建一个线程池并提交线程任务线程池源码解析参数认识 corePoolSize : 线程池的基本大小，当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。 runnableTaskQueue：任务对列，用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。 ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。 LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。 SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。 PriorityBlockingQueue：一个具有优先级得无限阻塞队列。 maximumPoolSize：线程池最大大小，线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。 ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug和定位问题时非常又帮助。 RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。 CallerRunsPolicy：只用调用者所在线程来运行任务。 DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。 DiscardPolicy：不处理，丢弃掉。 当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。 keepAliveTime ：线程活动保持时间，线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。 TimeUnit：线程活动保持时间的单位，可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。 类中其他属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 // 线程池的控制状态:用来表示线程池的运行状态（整型的高3位）和运行的worker数量（低29位） private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); // 29位的偏移量 private static final int COUNT_BITS = Integer.SIZE - 3; // 最大容量（2^29 - 1） private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; // runState is stored in the high-order bits // 线程运行状态，总共有5个状态，需要3位来表示（所以偏移量的29 = 32 - 3）/** * RUNNING : 接受新任务并且处理已经进入阻塞队列的任务 * SHUTDOWN ： 不接受新任务，但是处理已经进入阻塞队列的任务 * STOP : 不接受新任务，不处理已经进入阻塞队列的任务并且中断正在运行的任务 * TIDYING : 所有的任务都已经终止，workerCount为0， 线程转化为TIDYING状态并且调用terminated钩子函数 * TERMINATED: terminated钩子函数已经运行完成 **/ private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; private static final int STOP = 1 &lt;&lt; COUNT_BITS; private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; // 阻塞队列 private final BlockingQueue&lt;Runnable&gt; workQueue; // 可重入锁 private final ReentrantLock mainLock = new ReentrantLock(); // 存放工作线程集合 private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); // 终止条件 private final Condition termination = mainLock.newCondition(); // 最大线程池容量 private int largestPoolSize; // 已完成任务数量 private long completedTaskCount; // 线程工厂 private volatile ThreadFactory threadFactory; // 拒绝执行处理器 private volatile RejectedExecutionHandler handler; // 线程等待运行时间 private volatile long keepAliveTime; // 是否运行核心线程超时 private volatile boolean allowCoreThreadTimeOut; // 核心池的大小 private volatile int corePoolSize; // 最大线程池大小 private volatile int maximumPoolSize; // 默认拒绝执行处理器 private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); 构造方法12345678910111213141516171819202122public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || // 核心大小不能小于0 maximumPoolSize &lt;= 0 || // 线程池的初始最大容量不能小于0 maximumPoolSize &lt; corePoolSize || // 初始最大容量不能小于核心大小 keepAliveTime &lt; 0) // keepAliveTime不能小于0 throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); // 初始化相应的域 this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 了解了ThreadPoolExecutor的主要结构，再简单梳理一下“一个传入线程池的任务能够被最终正常执行需要经过的主要流程”，方法名称前面没有“XXX.”这种标注的都是ThreadPoolExecutor的方法： 提交任务12345678910111213141516171819202122232425262728293031323334353637383940/** 进行下面三步** 1. 如果运行的线程小于corePoolSize,则尝试使用用户定义的Runnalbe对象创建一个新的线程* 调用addWorker函数会原子性的检查runState和workCount，通过返回false来防止在不应* 该添加线程时添加了线程* 2. 如果一个任务能够成功入队列，在添加一个线城时仍需要进行双重检查（因为在前一次检查后* 该线程死亡了），或者当进入到此方法时，线程池已经shutdown了，所以需要再次检查状态，* 若有必要，当停止时还需要回滚入队列操作，或者当线程池没有线程时需要创建一个新线程* 3. 如果无法入队列，那么需要增加一个新线程，如果此操作失败，那么就意味着线程池已经shut* down或者已经饱和了，所以拒绝任务*/public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); // 获取线程池控制状态 int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; // worker数量小于corePoolSize if (addWorker(command, true)) // 添加worker // 成功则返回 return; // 不成功则再次获取线程池控制状态 c = ctl.get(); &#125; // 线程池处于RUNNING状态，将用户自定义的Runnable对象添加进workQueue队列 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // 再次检查，获取线程池控制状态 int recheck = ctl.get(); // 线程池不处于RUNNING状态，将自定义任务从workQueue队列中移除 if (! isRunning(recheck) &amp;&amp; remove(command)) // 拒绝执行命令 reject(command); else if (workerCountOf(recheck) == 0) // worker数量等于0 // 添加worker addWorker(null, false); &#125; else if (!addWorker(command, false)) // 添加worker失败 // 拒绝执行命令 reject(command);&#125; addWorker 原子性的增加workerCount。 将用户给定的任务封装成为一个worker，并将此worker添加进workers集合中。 启动worker对应的线程，并启动该线程，运行worker的run方法。 回滚worker的创建动作，即将worker从workers集合中删除，并原子性的减少workerCount。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; // 外层无限循环 // 获取线程池控制状态 int c = ctl.get(); // 获取状态 int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; // 状态大于等于SHUTDOWN，初始的ctl为RUNNING，小于SHUTDOWN ! (rs == SHUTDOWN &amp;&amp; // 状态为SHUTDOWN firstTask == null &amp;&amp; // 第一个任务为null ! workQueue.isEmpty())) // worker队列不为空 // 返回 return false; for (;;) &#123; // worker数量 int wc = workerCountOf(c); if (wc &gt;= CAPACITY || // worker数量大于等于最大容量 wc &gt;= (core ? corePoolSize : maximumPoolSize)) // worker数量大于等于核心线程池大小或者最大线程池大小 return false; if (compareAndIncrementWorkerCount(c)) // 比较并增加worker的数量 // 跳出外层循环 break retry; // 获取线程池控制状态 c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) // 此次的状态与上次获取的状态不相同 // 跳过剩余部分，继续循环 continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; // worker开始标识 boolean workerStarted = false; // worker被添加标识 boolean workerAdded = false; // Worker w = null; try &#123; // 初始化worker w = new Worker(firstTask); // 获取worker对应的线程 final Thread t = w.thread; if (t != null) &#123; // 线程不为null // 线程池锁 final ReentrantLock mainLock = this.mainLock; // 获取锁 mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. // 线程池的运行状态 int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || // 小于SHUTDOWN (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; // 等于SHUTDOWN并且firstTask为null if (t.isAlive()) // precheck that t is startable // 线程刚添加进来，还未启动就存活 // 抛出线程状态异常 throw new IllegalThreadStateException(); // 将worker添加到worker集合 workers.add(w); // 获取worker集合的大小 int s = workers.size(); if (s &gt; largestPoolSize) // 队列大小大于largestPoolSize // 重新设置largestPoolSize largestPoolSize = s; // 设置worker已被添加标识 workerAdded = true; &#125; &#125; finally &#123; // 释放锁 mainLock.unlock(); &#125; if (workerAdded) &#123; // worker被添加 // 开始执行worker的run方法 t.start(); // 设置worker已开始标识 workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) // worker没有开始 // 添加worker失败 addWorkerFailed(w); &#125; return workerStarted;&#125; 执行任务runWorker函数中会实际执行给定任务（即调用用户重写的run方法），并且当给定任务完成后，会继续从阻塞队列中取任务，直到阻塞队列为空（即任务全部完成）。在执行给定任务时，会调用钩子函数，利用钩子函数可以完成用户自定义的一些逻辑。在runWorker中会调用到getTask函数和processWorkerExit钩子函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final void runWorker(Worker w) &#123; // 获取当前线程 Thread wt = Thread.currentThread(); // 获取w的firstTask Runnable task = w.firstTask; // 设置w的firstTask为null w.firstTask = null; // 释放锁（设置state为0，允许中断） w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; while (task != null || (task = getTask()) != null) &#123; // 任务不为null或者阻塞队列还存在任务 // 获取锁 w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || // 线程池的运行状态至少应该高于STOP (Thread.interrupted() &amp;&amp; // 线程被中断 runStateAtLeast(ctl.get(), STOP))) &amp;&amp; // 再次检查，线程池的运行状态至少应该高于STOP !wt.isInterrupted()) // wt线程（当前线程）没有被中断 wt.interrupt(); // 中断wt线程（当前线程） try &#123; // 在执行之前调用钩子函数 beforeExecute(wt, task); Throwable thrown = null; try &#123; // 运行给定的任务 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; // 执行完后调用钩子函数 afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; // 增加给worker完成的任务数量 w.completedTasks++; // 释放锁 w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; // 处理完成后，调用钩子函数 processWorkerExit(w, completedAbruptly); &#125;&#125; 此函数用于从workerQueue阻塞队列中获取Runnable对象，由于是阻塞队列，所以支持有限时间等待（poll）和无限时间等待（take）。在该函数中还会响应shutDown和、shutDownNow函数的操作，若检测到线程池处于SHUTDOWN或STOP状态，则会返回null，而不再返回阻塞队列中的Runnalbe对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; // 无限循环，确保操作成功 // 获取线程池控制状态 int c = ctl.get(); // 运行的状态 int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; // 大于等于SHUTDOWN（表示调用了shutDown）并且（大于等于STOP（调用了shutDownNow）或者worker阻塞队列为空） // 减少worker的数量 decrementWorkerCount(); // 返回null，不执行任务 return null; &#125; // 获取worker数量 int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; // 是否允许coreThread超时或者workerCount大于核心大小 if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) // worker数量大于maximumPoolSize &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; // workerCount大于1或者worker阻塞队列为空（在阻塞队列不为空时，需要保证至少有一个wc） if (compareAndDecrementWorkerCount(c)) // 比较并减少workerCount // 返回null，不执行任务，该worker会退出 return null; // 跳过剩余部分，继续循环 continue; &#125; try &#123; Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : // 等待指定时间 workQueue.take(); // 一直等待，直到有元素 if (r != null) return r; // 等待指定时间后，没有获取元素，则超时 timedOut = true; &#125; catch (InterruptedException retry) &#123; // 抛出了被中断异常，重试，没有超时 timedOut = false; &#125; &#125;&#125; processWorkerExit函数是在worker退出时调用到的钩子函数，而引起worker退出的主要因素如下 阻塞队列已经为空，即没有任务可以运行了。 调用了shutDown或shutDownNow函数 此函数会根据是否中断了空闲线程来确定是否减少workerCount的值，并且将worker从workers集合中移除并且会尝试终止线程池。 123456789101112131415161718192021222324252627282930313233private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; if (completedAbruptly) // 如果被中断，则需要减少workCount // If abrupt, then workerCount wasn't adjusted decrementWorkerCount(); // 获取可重入锁 final ReentrantLock mainLock = this.mainLock; // 获取锁 mainLock.lock(); try &#123; // 将worker完成的任务添加到总的完成任务中 completedTaskCount += w.completedTasks; // 从workers集合中移除该worker workers.remove(w); &#125; finally &#123; // 释放锁 mainLock.unlock(); &#125; // 尝试终止 tryTerminate(); // 获取线程池控制状态 int c = ctl.get(); if (runStateLessThan(c, STOP)) &#123; // 小于STOP的运行状态 if (!completedAbruptly) &#123; int min = allowCoreThreadTimeOut ? 0 : corePoolSize; if (min == 0 &amp;&amp; ! workQueue.isEmpty()) // 允许核心超时并且workQueue阻塞队列不为空 min = 1; if (workerCountOf(c) &gt;= min) // workerCount大于等于min // 直接返回 return; // replacement not needed &#125; // 添加worker addWorker(null, false); &#125;&#125; 关闭线程池123456789101112131415161718public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // 检查shutdown权限 checkShutdownAccess(); // 设置线程池控制状态为SHUTDOWN advanceRunState(SHUTDOWN); // 中断空闲worker interruptIdleWorkers(); // 调用shutdown钩子函数 onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; // 尝试终止 tryTerminate();&#125; 1234567891011121314151617181920212223242526272829303132333435363738final void tryTerminate() &#123; for (;;) &#123; // 无限循环，确保操作成功 // 获取线程池控制状态 int c = ctl.get(); if (isRunning(c) || // 线程池的运行状态为RUNNING runStateAtLeast(c, TIDYING) || // 线程池的运行状态最小要大于TIDYING (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) // 线程池的运行状态为SHUTDOWN并且workQueue队列不为null // 不能终止，直接返回 return; if (workerCountOf(c) != 0) &#123; // 线程池正在运行的worker数量不为0 // Eligible to terminate // 仅仅中断一个空闲的worker interruptIdleWorkers(ONLY_ONE); return; &#125; // 获取线程池的锁 final ReentrantLock mainLock = this.mainLock; // 获取锁 mainLock.lock(); try &#123; if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; // 比较并设置线程池控制状态为TIDYING try &#123; // 终止，钩子函数 terminated(); &#125; finally &#123; // 设置线程池控制状态为TERMINATED ctl.set(ctlOf(TERMINATED, 0)); // 释放在termination条件上等待的所有线程 termination.signalAll(); &#125; return; &#125; &#125; finally &#123; // 释放锁 mainLock.unlock(); &#125; // else retry on failed CAS &#125;&#125; 123456789101112131415161718192021222324252627private void interruptIdleWorkers(boolean onlyOne) &#123; // 线程池的锁 final ReentrantLock mainLock = this.mainLock; // 获取锁 mainLock.lock(); try &#123; for (Worker w : workers) &#123; // 遍历workers队列 // worker对应的线程 Thread t = w.thread; if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; // 线程未被中断并且成功获得锁 try &#123; // 中断线程 t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; finally &#123; // 释放锁 w.unlock(); &#125; &#125; if (onlyOne) // 若只中断一个，则跳出循环 break; &#125; &#125; finally &#123; // 释放锁 mainLock.unlock(); &#125;&#125; 参考： http://www.cnblogs.com/xuzhenmin/p/3386592.html http://blog.csdn.net/liuchuanhong1/article/details/52042182]]></content>
      <categories>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于try、catch、finally的一些问题]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%2F%E5%85%B3%E4%BA%8Etry%E3%80%81catch%E3%80%81finally%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[下面看一个例子，来讲解java里面中try、catch、finally的处理流程例1123456789101112131415161718192021public class TryCatchFinally &#123; @SuppressWarnings("finally") public static final String test() &#123; String t = ""; try &#123; t = "try"; return t; &#125; catch (Exception e) &#123; t = "catch"; return t; &#125; finally &#123; t = "finally"; &#125; &#125; public static void main(String[] args) &#123; System.out.print(TryCatchFinally.test()); &#125;&#125; 首先程序执行try语句块，把变量t赋值为try，由于没有发现异常，接下来执行finally语句块，把变量t赋值为finally，然后return t，则t的值是finally，最后t的值就是finally，程序结果应该显示finally，但是实际结果为try. 通过字节码，我们发现，在try语句的return块中，return 返回的引用变量（t 是引用类型）并不是try语句外定义的引用变量t，而是系统重新定义了一个局部引用t’，这个引用指向了引用t对应的值，也就是try ，即使在finally语句中把引用t指向了值finally，因为return的返回引用已经不是t ，所以引用t的对应的值和try语句中的返回值无关了。 下面在看一个例子：例212345678910111213141516171819202122public class TryCatchFinally &#123; @SuppressWarnings("finally") public static final String test() &#123; String t = ""; try &#123; t = "try"; return t; &#125; catch (Exception e) &#123; // result = "catch"; t = "catch"; return t; &#125; finally &#123; t = "finally"; return t; &#125; &#125; public static void main(String[] args) &#123; System.out.print(TryCatchFinally.test()); &#125; &#125; 这里稍微修改了 第一段代码，只是在finally语句块里面加入了 一个 return t 的表达式。 按照第一段代码的解释，先进行try{}语句，然后在return之前把当前的t的值try保存到一个变量t’，然后执行finally语句块，修改了变量t的值，在返回变量t。 我们发现try语句中的return语句给忽略。可能jvm认为一个方法里面有两个return语句并没有太大的意义，所以try中的return语句给忽略了，直接起作用的是finally中的return语句，所以这次返回的是finally。 接下来在看看复杂一点的例子：例3123456789101112131415161718192021222324public class TryCatchFinally &#123; @SuppressWarnings("finally") public static final String test() &#123; String t = ""; try &#123; t = "try"; Integer.parseInt(null); return t; &#125; catch (Exception e) &#123; t = "catch"; return t; &#125; finally &#123; t = "finally"; // System.out.println(t); // return t; &#125; &#125; public static void main(String[] args) &#123; System.out.print(TryCatchFinally.test()); &#125;&#125; 这里面try语句里面会抛出 java.lang.NumberFormatException，所以程序会先执行catch语句中的逻辑，t赋值为catch，在执行return之前，会把返回值保存到一个临时变量里面t ‘，执行finally的逻辑，t赋值为finally，但是返回值和t’，所以变量t的值和返回值已经没有关系了，返回的是catch 例4：12345678910111213141516171819202122public class TryCatchFinally &#123; @SuppressWarnings("finally") public static final String test() &#123; String t = ""; try &#123; t = "try"; Integer.parseInt(null); return t; &#125; catch (Exception e) &#123; t = "catch"; return t; &#125; finally &#123; t = "finally"; return t; &#125; &#125; public static void main(String[] args) &#123; System.out.print(TryCatchFinally.test()); &#125;&#125; 这个和例2有点类似，由于try语句里面抛出异常，程序转入catch语句块，catch语句在执行return语句之前执行finally，而finally语句有return,则直接执行finally的语句值，返回finally 例5：123456789101112131415161718192021222324public class TryCatchFinally &#123; @SuppressWarnings("finally") public static final String test() &#123; String t = ""; try &#123; t = "try"; Integer.parseInt(null); return t; &#125; catch (Exception e) &#123; t = "catch"; Integer.parseInt(null); return t; &#125; finally &#123; t = "finally"; //return t; &#125; &#125; public static void main(String[] args) &#123; System.out.print(TryCatchFinally.test()); &#125;&#125; 这个例子在catch语句块添加了Integer.parser(null)语句，强制抛出了一个异常。然后finally语句块里面没有return语句。继续分析一下，由于try语句抛出异常，程序进入catch语句块，catch语句块又抛出一个异常，说明catch语句要退出，则执行finally语句块，对t进行赋值。然后catch语句块里面抛出异常。结果是抛出java.lang.NumberFormatException异常 例子6：12345678910111213141516171819202122232425public class TryCatchFinally &#123; @SuppressWarnings("finally") public static final String test() &#123; String t = ""; try &#123; t = "try"; Integer.parseInt(null); return t; &#125; catch (Exception e) &#123; t = "catch"; Integer.parseInt(null); return t; &#125; finally &#123; t = "finally"; return t; &#125; &#125; public static void main(String[] args) &#123; System.out.print(TryCatchFinally.test()); &#125;&#125; 这个例子和上面例子中唯一不同的是，这个例子里面finally 语句里面有return语句块。try catch中运行的逻辑和上面例子一样，当catch语句块里面抛出异常之后，进入finally语句快，然后返回t。则程序忽略catch语句块里面抛出的异常信息，直接返回t对应的值 也就是finally。方法不会抛出异常 例子7：123456789101112131415161718192021public class TryCatchFinally &#123; @SuppressWarnings("finally") public static final String test() &#123; String t = ""; try &#123; t = "try"; Integer.parseInt(null); return t; &#125; catch (NullPointerException e) &#123; t = "catch"; return t; &#125; finally &#123; t = "finally"; &#125; &#125; public static void main(String[] args) &#123; System.out.print(TryCatchFinally.test()); &#125;&#125; 这个例子里面catch语句里面catch的是NPE异常，而不是java.lang.NumberFormatException异常，所以不会进入catch语句块，直接进入finally语句块，finally对s赋值之后，由try语句抛出java.lang.NumberFormatException异常。 例子8123456789101112131415161718192021222324public class TryCatchFinally &#123; @SuppressWarnings("finally") public static final String test() &#123; String t = ""; try &#123; t = "try"; Integer.parseInt(null); return t; &#125; catch (NullPointerException e) &#123; t = "catch"; return t; &#125; finally &#123; t = "finally"; return t; &#125; &#125; public static void main(String[] args) &#123; System.out.print(TryCatchFinally.test()); &#125;&#125; 和上面的例子中try catch的逻辑相同，try语句执行完成执行finally语句，finally赋值s 并且返回s ，最后程序结果返回finally 例子9：12345678910111213141516171819202122public class TryCatchFinally &#123; @SuppressWarnings("finally") public static final String test() &#123; String t = ""; try &#123; t = "try";return t; &#125; catch (Exception e) &#123; t = "catch"; return t; &#125; finally &#123; t = "finally"; String.valueOf(null); return t; &#125; &#125; public static void main(String[] args) &#123; System.out.print(TryCatchFinally.test()); &#125;&#125; 这个例子中，对finally语句中添加了String.valueOf(null), 强制抛出NPE异常。首先程序执行try语句，在返回执行，执行finally语句块，finally语句抛出NPE异常，整个结果返回NPE异常。 对以上所有的例子进行总结 try、catch、finally语句中，在如果try语句有return语句，则返回的之后当前try中变量此时对应的值，此后对变量做任何的修改，都不影响try中return的返回值 如果finally块中有return 语句，则返回try或catch中的返回语句忽略。 如果finally块中抛出异常，则整个try、catch、finally块中抛出异常 所以使用try、catch、finally语句块中需要注意的是 尽量在try或者catch中使用return语句。通过finally块中达到对try或者catch返回值修改是不可行的。 finally块中避免使用return语句，因为finally块中如果使用return语句，会显示的消化掉try、catch块中的异常信息，屏蔽了错误的发生 finally块中避免再次抛出异常，否则整个包含try语句块的方法回抛出异常，并且会消化掉try、catch块中的异常 节选自God Is Coder]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑客与画家读后感]]></title>
    <url>%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6%E8%AF%BB%E5%90%8E%E6%84%9F.html</url>
    <content type="text"><![CDATA[保罗·格雷厄姆 – 硅谷创业之父，美国创业学者，前雅虎高级工程师 为什么书呆子不受欢迎？因为他的心思压根没有放在使自己受欢迎的这件事上因为在他们看来与其把时间花在这种无关紧要的事上，不如多花点时间在如何让自己变得更聪明的事情上。事实上，绝大多数的书呆子并不”呆”，可能在他们的心里嘲笑他们的人才是最呆的。 黑客与画家黑客与画家同样都为创造者，都试图创作出优秀的作品。对于他们来说，计算机只是创作的媒介，像建筑师手里的混凝土或者画家手里的颜料。作者认为黑客的新想法往往不是来自于那些名字里只有”计算机”的理论领域，作者大学时上机编程时往往被教育为在纸上将程序搞清楚，可是作者却总是一股脑的将代码堆上去再慢慢修改，直到现在依然认为这是对的。 编程语言首要的特性应该是允许动态扩展编程语言是用来帮助思考程序的，而不是用来表达你已经相好的程序这才是黑客使用计算机创作时的真实写照，将编程语言当作一只铅笔，随意涂抹，擦擦改改，最终打磨成最优秀的作品。 因为黑客的做事风格，他们的职业生涯可能并不好过，因为大学和实验室强迫他们成为科学家，企业强迫他们成为工程师。当雅虎收购Viaweb的时候，他们问我想做什么，作者回答说想继续做一名黑客。作者到了雅虎之后才发现，在他们看来，黑客的工作就是用软件实现某个功能，而不是设计软件，在那里，程序员被当作技工，职责就是将产品经理的构想翻译成代码，那么他其实是与一个挖水沟的工人是一样的，从这头挖到那头，仅此而已。 大公司往往避免设计上的灾难，选择减少设计结果的优秀性，这样做会把失败的可能性降到最低，同时也把高利润排除在外。但这对于大公司来说并不是问题，因为生产优秀代码不是它们的获胜手段，它们只需要做到不太烂，就能赢，因为他们有自己的城堡。 所以，开发优秀软件的方法之一就是自己创业,去做自己喜欢做的事。比如白天工作，晚上开发优美的软件。作者创业的时候，面试程序员的时候，主要关注的事情就是业余时间他们写了那些软件。因为你不爱一件事，你不可能把它做得真正优秀，要是你很爱编程，你就不可避免的会开发你自己的项目。 黑客是创作者，同时实践学习编程，同时观看优秀的源代码学会编程。作者认为过早优化是一件危险的事情，过早设计同样如此。黑客从事就不是机械式的工作，他必须具备灵感，同时工作的热情也是跌宕起伏的。就像你有一辆手动变速的汽车一样，你把它开上上，也得是不是松开离合器，防止他熄火。同样，暂时放手有时也能防止热情熄灭，有时只是为了更好的冲上山坡。 对于编程，就意味着你可以把Bug留到最后解决。消灭Bug的过程就像解一道数学题，已知许许多多的约束条件，根据条件解方程就可以了。比如方程结果是X,却得出了Y,你知道自己肯定能搞定，所以做起来就很轻松了。 换位思考，从用户的角度出发，别指望用户能去阅读使用手册，软件的使用方式最好能符合用户的直觉。程序写出来是给人看的，附带能在机器上运行的 ——《计算机程序的结构与解释》 不能说的话只要你能看到别人看不到或不敢看的东西，你就有很大的优势，敢说出别人想不到或不敢说的想法，你就是勇士。所谓的”时尚” 本质上就是自己看不见自己的样子，好比我们在地球，却感觉不到地球在动。 令人真正惊恐的的是，流行一时的不仅有衣服，还有道德观念。一旦你的观点脱节或超前于”时尚流行“，你就可能会受到嘲讽。就像今天说地球围绕着太阳运转真是再平常不过了，但是换在17世纪的欧洲，能说出这样的的话是冒着生命危险的，不怕死的伽利略就是这样，结果遭到了宗教法庭的审判。 所以一大多数人接受流行，不是因为想要与众不同，而是因为害怕与众不同，不想沦为一个人们口中的异类。 很多重要的观点没人敢说。一些想法会被贴上“消极主义”，“失败分子”等标签，有想法是好事但不代表你可以口无遮拦，如果你口无遮拦，你就没时间做正事了，为了与他们论战，你不得不变成一个语言学家，同时与笨蛋辩论，你会变成笨蛋。 做出伟大产品的公司，自我评价往往以“批评”和“自嘲”为主，而不是以“肯定”和“表扬”为主。 永远质疑，如果别人告诉你应该相信什么，你就真的相信了，那你就会和别人一样犯下同样的错误，但想要摆脱自己时代的流行，需要一点自觉，尽可能的远离人群（舆论），观察正在发生的事，特别是注意那些被压制的思想（关于微博舆论，关于国产手机的讨论）。 小时候，每个人都会鼓励你不断成长，变成一个心智成熟，不在耍小孩子脾气的人，但是，很少有人鼓励你继续成长，变成一个怀疑和抵制社会错误潮流的人。 如果自己就是潮水的一部分，又怎么能看见潮流的方向呢？你只能保证质疑，是不是成为一颗飞跃的浪花，以更高的高度去审视这所谓的”潮流“。 良好的坏习惯黑客是不服从管教的，这就是他们的本性，事实上，每个人都不想被管教，政府对于适当的不服从管教，保持宽容不会有太大的坏处，反而很有利于国家优势，作者也说它使得美国不仅能吸引聪明人，还能吸引那些很有自负的人，这也是为什么硅谷出现在美国，而不是其他国家的原因。法律和当前政局一定程度上限制了黑客的自由，这恰恰不利于黑客的发展。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql关键字执行顺序]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySql%E5%85%B3%E9%94%AE%E5%AD%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.html</url>
    <content type="text"><![CDATA[执行顺序总结 FROM ON JOIN WHERE GROUP BY HAVING SELECT DISTINCT ORDER BY LIMIT 配图 以上总结为Mysql查询性能优化]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开篇]]></title>
    <url>%2F%E9%9A%8F%E8%AE%B0%2F%E5%BC%80%E7%AF%87.html</url>
    <content type="text"><![CDATA[第一次搭建个人博客小记初衷 积攒了很多优秀博客论文和自己关于技术的想法和实现，却没有一个好的平台去记录和呈现，偶然遇见GitHubPages和Hexo,正合心意，利用业余时间利用它们搭建了该博客平台，也希望从此认识更多热爱技术的人并与他们分享和讨论关于技术的问题和思考，一起学习与进步。 心情昨晚酒喝的有点多，导致今天有些恍惚，幸好年前的工作事项的实现任务也都已进入尾声，让我得以有空在这写下这篇博客，今天给自己的主要任务就是完成该博客的搭建工作，现已部署上线，心情自然也是非常开心。今天就写到这吧，得去继续完善开发框架了]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>心情记录</tag>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心智社会读后感]]></title>
    <url>%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E5%BF%83%E6%99%BA%E7%A4%BE%E4%BC%9A%E8%AF%BB%E5%90%8E%E6%84%9F.html</url>
    <content type="text"><![CDATA[《心智社会》读书感马文·明斯基 – 美国国家科学院的成员，美国人工智能学会的前任主席 NO.1目前这本书我只看了20多页，用通俗易懂的语言和生动的例子去阐述人类思维和意识，帮助人们去认识人类智慧的如何产生，进而去帮助人们去研究机器学习和创造人工智能。 作者认为大脑不过是肉做的机器”，大脑中不具备思维的微小单元可以组成各种思维——意识、精神活动、常识、思维、智能、自我，最终形成“统一的智慧”,这种智能组合就是“心智社会”。 但我认为的这些微小单元共同组成了智能体，也就是生物。人属于一种高级生物，智慧或者说意识的存在让我们这些高级智能体共同组成了一个庞大的心智社会。 也就说人与其他生物或者说和机器最大的不同便是意识了，书中有个很有趣的例子，为什么人类下雨不想被淋湿，却愿意在卫生间沐浴”这种3岁小孩都知道的问题，计算机就会感到费解，这也就恰好说明意识的重要性了。 NO.2个体之间的相似之处源自思维的本质，而构成思维的那些关系复杂且外表、形式、种类各不相同的物质原子全部都是微不足道的 物理学家用几条定律就解释了全世界甚至全宇宙，但对人类的思维来说行不通。事实上直到今天，人类依然无法理解自己大脑是如何运作的，，因为人类大脑是由几百种不同的脑细胞协作的，即使理解了单种细胞的功能也很难理解几百种细胞之间如何协同运作。 人类是机器吗？或者说机器可以像人类一样吗？人类的一个简单动作就需要机器成千上万的程序协同运作且高度自动化，但只限于现在，随着科技的快速发展，未来的机器实现这套动作可能简单的多。那有的人可能会说“太可笑了，我倒不觉得自己像个机器”，但书中说如果你不是一台机器，你又怎么会知道身为一台机器是什么感觉呢？那有的人可能又会说，我会思考，但我想说的就像你会开车，但你并不知道发动机是如何运作的，会使用某种工具不代表你熟悉它的工作原理，连你自己的都没有弄清楚，又怎么敢保证自己不是机器呢？ 开个玩笑，人人都知道机器只能以无生命的机械方式行动，但我们无法预知机器的未来是什么样子，就像假如火星人十亿年前到访地球看到由一些细胞组成的简单团块，可能火星人也没想到会有现在的人类文明吧，机器也是同样的道理。 也许人类只是机器进化到的一个新高度，人工智能是有史以来能最大限度增强人类能力的东西，人类也并不是进化的终点。 NO.3 何为自我？ 任何人或物的身份、特征、或基本品质 一个特定的人的身份、人格、个体性等；一个人对自己区别于他人的称呼–《韦氏词典》 人们总喜欢去研究他人或者事物，却很少认真的去研究自己，事实上，关于“自我”的理念中，包含着我们是什么的概念，这些信念又包含着我们能做什么和我们可能倾向于做什么。 此外，有时候我们认为自我是单一的、自相一致的实体，有时我们又认为自我是分散的。比如我们会说我感觉，我认为，我想要等。但有些人可能会出现一部分我想要这样，一部分我想要那样。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis与其他ORMs比较]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E6%80%9D%E6%83%B3%2FMyBatis%E4%B8%8E%E5%85%B6%E4%BB%96ORMs%E6%AF%94%E8%BE%83.html</url>
    <content type="text"><![CDATA[比较对象关系映射（ORM）框架允许我们从面向对象的语言访问关系数据库。多年来，我已经使用了几个用于Java的Hibernate / JPA，用于JavaScript的Bookshelf.js和Sequelize，仅举几例。我从来没有完全满意这些解决方案，因为这样或那样，他们不符合我的思维方式。最近，我尝试了MyBatis，呼吸新鲜空气！让我解释一下为什么。 域实体应该没有持久性问题如果您遵循领域驱动设计，您可能会认同领域实体应该独立的想法。你不应该拖着一个持久性框架与他们。领域实体形成了六角形体系结构的内核，它只关注业务逻辑。你应该能够以任何你想要的方式站起来这个核心 - 通过构建新的对象或从数据库中检索它们，核心本身不应该在意。许多ORM污染这个核心与持久性的担忧，我不喜欢这一点。例如，Bookshelf强迫你使用Model对象定义实体，Sequelize使用sequelize.define（）。这会在实体内创建“隐藏的”属性和方法，教导他们坚持自己。我宁愿拥有专注于业务逻辑的纯Java / JavaScript对象，然后教导持久性框架坚持它们。 那么，这正是MyBatis所做的。实体是POJO，对持久性一无所知（参见这里）。相反，你教MyBatis如何保存和检索这些实体使用SQL语句和结果图（见这里）。对于琐碎的对象，你甚至不需要定义结果地图，MyBatis自动计算出来。 让我控制SQL对于任何使用关系数据库的严重项目，您无法逃避学习SQL。大多数ORM试图通过提供更高级别的抽象来使您与SQL隔离。但是作为交换，他们强迫你学习一个新的API或一个抽象的查询语言。这些API /查询语言无论如何都会生成SQL，所以唯一的区别是你不知道它们是什么，直到你打开引擎盖。在很多情况下，我可以用单个语句编写的查询将以两个或更多语句生成，从而降低性能。现在我突然回到ORM并调整它以产生更高效的查询。有时候，API不够丰富，无法满足所需要的任何事情，无论如何，我都必须逃避SQL语言。为什么要这么麻烦？如果我必须知道SQL，为什么不直接自己写，直接优化呢？教学框架将结果映射到对象中要容易得多。 猜猜看，这正是MyBatis所做的 - 在这里看到结果图。它教MyBatis如何将查询结果映射到一个Transaction对象，并引用一个Account和一个Category。我最终得到更清晰和可理解的代码。 结论我希望你能明白为什么我喜欢MyBatis。这将是我未来Java的默认ORM。不过，我还没有看到类似的JavaScript解决方案。如果有这样的解决方案，你会切换到吗？我很想听听你的想法。 摘录自纳雷什·巴蒂亚]]></content>
      <categories>
        <category>技术思考</category>
      </categories>
      <tags>
        <tag>Mybaits</tag>
        <tag>技术思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA快捷键总结]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%2FIDE%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[CtrlCtrl + F 在当前文件进行文本查找 （必备）Ctrl + R 在当前文件进行文本替换 （必备）Ctrl + Z 撤销 （必备）Ctrl + Y 删除光标所在行 或 删除选中的行 （必备）Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备）Ctrl + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备）Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备） AltAlt + Home 定位 / 显示到当前文件的 Navigation BarAlt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备） ShiftShift + F4 对当前打开的文件，使用新Windows窗口打开，旧窗口保留Shift + F6 对文件 / 文件夹 重命名Shift + F7 在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法Shift + F8 在 Debug 模式下，跳出，表现出来的效果跟 F9 一样Shift + F9 等效于点击工具栏的 Debug 按钮 Ctrl + AltCtrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 （必备）Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用 （必备）Ctrl + Alt + 左方向键 退回到上一个操作的地方 （必备）Ctrl + Alt + 右方向键 前进到上一个操作的地方 （必备） Ctrl + ShiftCtrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件 （必备）Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件（必备）Ctrl + Shift + J 自动将下一行合并到当前行末尾 （必备）Ctrl + Shift + Z 取消撤销 （必备）Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）Ctrl + Shift + N 通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备）Ctrl + Shift + U 对选中的代码进行大 / 小写轮流转换 （必备）Ctrl + Shift + / 代码块注释 （必备）Ctrl + Shift + Space 智能代码提示Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 （必备）Ctrl + Shift + Backspace 退回到上次修改的地方 Alt + ShiftAlt + Shift + 前方向键 移动光标所在行向上移动Alt + Shift + 后方向键 移动光标所在行向下移动 其他F2 跳转到下一个高亮错误 或 警告位置 （必备）F3 在查找模式下，定位到下一个匹配处F4 编辑源F7 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中F8 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内F9 在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上F11 添加书签F12 回到前一个工具窗口Tab 缩进ESC 从工具窗口进入代码文件窗口]]></content>
      <categories>
        <category>工作记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作踩坑记录]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%2F%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[Nginx匹配头大小写问题:解决办法：匹配头换成小写解决 Java.awt.AWTError:12345&gt; AssistiveTechnology not found: com.sun.java.accessibility.AccessBridge&gt; at java.awt.Toolkit.loadAssistiveTechnologies(Toolkit.java:773)at&gt; java.awt.Toolkit.getDefaultToolkit(Toolkit.java:872) at&gt; javax.swing.UIManager.&lt;clinit&gt;(UIManager.java:357) at&gt; schsys.view.common.Login.&lt;clinit&gt;(Login.java:77) 解决办法：C盘用户文件根目录下有个.accessibility.properties文件，删除该配置文件 页面总是显示后台返回的字符: 解决办法：@Responsbody，@RestController去掉 Maven下tomcat修改jsp无法生效:解决办法: 不寻常bug,自动变好 跨域访问方法:解决办法：前端Jsonp请求，后台HttpClient请求，Nginx代理，Tomcat自主跨域 Vue.js前端跨域访问Nginx做代理，SessionId丢失解决办法：采用Vue.js本身做代理服务器 MyBatis映射问题，There is no getter XXX:解决办法：将Mapper方法中参数名改为Vule或者_paramter Mysql5.7 group by问题: 通过 explain 查看执行计划，看到没有 limit 的时候，少了一个 DERIVED 操作，估计是内部优化了，认为 ORDER BY 在这种语法中可忽略，有 LIMIT 限制涉及排序后的结果，不会忽略 ORDER BY，可以达到预期 不需要limit的话，mysql5.7中only_full_group_by这个模式是默认开启的 ，修改my.cnf（windows下是my.ini）配置文件，删掉only_full_group_by这一项，重启解决 我的项目中将id字段加DISTINCT同样也能解决问题 编译没问题，运行找不到类:解决办法：检查target中是否缺少相关文件 高并发下MD5加密结果不一致:解决办法：dighest方法不支持线程安全，换成apache md5hex解决 高并发下静态全局变量不一致:解决办法：改成非静态全局变量，每次都新建一个对象或采用ThreadLocal 阿里域名备案与解析报网站未备案:解决办法：域名备案与解析需要都在阿里云服务下才可用 SpringSecurity 在前端标签中无效 :解决办法：角色名必须为ROLE_开头才可用 Nginx 找不到windows映射路径解决办法：匹配路径需要反斜杠 location /upload/ { root D:/SVN/zhizhao-offical/target; index index.html index.htm; }]]></content>
      <categories>
        <category>工作记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[守护线程]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%2F%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B.html</url>
    <content type="text"><![CDATA[守护线程Demo在Java中有两种线程：一种是普通线程，另一种是守护线程 守护线程：顾名思义就是守护的线程，它是为非守护线程服务的线程。 JVM虚拟机正常退出的时机就是系统中不存在非守护线程的时候，也就是说系统中不存在普通线程时虚拟机退出而不管守护线程是否还在运行 生活场景举例：普通线程相当于是主人，守护线程就是保姆，保姆是为了主人服务的。当主人都挂了，那么保姆可以存在也可以不存在 来一道面试题：一个主线程，三个子线程，9个守护线程，他们停止的顺序时什么？答：我们理解了上面讲的虚拟机退出时机再结合生活场景的例子，很容易就能搞明白这个问题！主线程相当于家庭、子线程相当于主人、守护线程相当于保姆或者是奴才，那么当我们的主人挂了，保姆可能还要继续打扫房子，但是房子也坏了消失了，那么保姆或奴才也就没必要存在了。所以说守护线程是最后才会停止的。那么主线程和子线程是谁先停止呢？这个其实很简单，我们想想，在一个main方法中启动一个线程打印一条语句，那么只有当这个线程停止之后，控制台的那个红色框才会置灰，也就是说main线程才会死亡。那么这个问题的答案就是：子、主、守护 手动敲个主线程和守护线程代码:1234567891011121314151617public class DaemonThreadDemo &#123; public static void main(String[] args) throws InterruptedException &#123; Thread mainThread = new Thread(new Runnable() &#123; @Override public void run() &#123; Thread childThread = new Thread(new ClildThread()); childThread.setDaemon(true); childThread.start(); System.out.println("I’m main thread…"); &#125; &#125;); mainThread.start(); Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + "主线程结束"); &#125;&#125; 1234567891011121314class ClildThread implements Runnable &#123; @Override public void run() &#123; while (true) &#123; System.out.println("I’m child thread.."); try &#123; TimeUnit.MILLISECONDS.sleep(100); //Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>守护线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx配置详解]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%2FNginx%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[定义Nginx运行的用户和用户组1user www www; nginx进程数，建议设置为等于CPU总核心数。1worker_processes 8; 配置文件正确性测试1./nginx -t 全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]1error_log /var/log/nginx/error.log info; 进程文件1pid /var/run/nginx.pid; 一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。1worker_rlimit_nofile 65535; 设定http服务器1234http&#123;include mime.types; #文件扩展名与文件类型映射表default_type application/octet-stream; #默认文件类型 charset utf-8; #默认编码123456789server_names_hash_bucket_size 128; #服务器名字的hash表大小client_header_buffer_size 32k; #上传文件大小限制large_client_header_buffers 4 64k; #设定请求缓client_max_body_size 8m; #设定请求缓sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。tcp_nopush on; #防止网络阻塞tcp_nodelay on; #防止网络阻塞keepalive_timeout 120; #长连接超时时间，单位是秒 FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。1234567fastcgi_connect_timeout 300;fastcgi_send_timeout 300;fastcgi_read_timeout 300;fastcgi_buffer_size 64k;fastcgi_buffers 4 64k;fastcgi_busy_buffers_size 128k;fastcgi_temp_file_write_size 128k; gzip模块设置123456gzip on; #开启gzip压缩输出gzip_min_length 1k; #最小压缩文件大小gzip_buffers 4 16k; #压缩缓冲区gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）gzip_comp_level 2; #压缩等级gzip_types text/plain application/x-javascript text/css application/xml; 压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。1gzip_vary on; 负载均衡123456upstream blog.ha97.com &#123;#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。server 192.168.80.121:80 weight=3;server 192.168.80.122:80 weight=2;server 192.168.80.123:80 weight=3;&#125; 虚拟主机的配置1234567891011121314server&#123;#监听端口listen 80;#域名可以有多个，用空格隔开server_name www.ha97.com ha97.com;index index.html index.htm index.php;root /data/www/ha97;location ~ .*.(php|php5)?$&#123;fastcgi_pass 127.0.0.1:9000;fastcgi_index index.php;include fastcgi.conf;&#125; 图片缓存时间设置1234location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$&#123;expires 10d;&#125; JS和CSS缓存时间设置1234location ~ .*.(js|css)?$&#123;expires 1h;&#125; 日志格式设定123log_format access '$remote_addr - $remote_user [$time_local] "$request" ''$status $body_bytes_sent "$http_referer" ''"$http_user_agent" $http_x_forwarded_for'; 定义本虚拟主机的访问日志1access_log /var/log/nginx/ha97access.log access; 对 “/“ 启用反向代理1234567891011121314151617location / &#123;proxy_pass http://127.0.0.1:88;proxy_redirect off;proxy_set_header X-Real-IP $remote_addr;#后端的Web服务器可以通过X-Forwarded-For获取用户真实IPproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;#以下是一些反向代理的配置，可选。proxy_set_header Host $host;client_max_body_size 10m; #允许客户端请求的最大单文件字节数client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）proxy_temp_file_write_size 64k; 设定缓存文件夹大小，大于这个值，将从upstream服务器传} 123456789101112131415161718192021222324#设定查看Nginx状态的地址location /NginxStatus &#123;stub_status on;access_log on;auth_basic "NginxStatus";auth_basic_user_file conf/htpasswd;#htpasswd文件的内容可以用apache提供的htpasswd工具来产生。&#125;#本地动静分离反向代理配置#所有jsp的页面均交由tomcat或resin处理location ~ .(jsp|jspx|do)?$ &#123;proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_pass http://127.0.0.1:8080;&#125;#所有静态文件由nginx直接读取不经过tomcat或resinlocation ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$&#123; expires 15d; &#125;location ~ .*.(js|css)?$&#123; expires 1h; &#125;&#125;&#125;]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>技术总结</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何阅读一本书读后感]]></title>
    <url>%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E5%90%8E%E6%84%9F.html</url>
    <content type="text"><![CDATA[《如何阅读一本书》读书感莫提默·J．艾德勒（1902－2001）以学者、教育家、编辑人等多重面貌享有盛名。除了写作《如何阅读一本书》外，以主编《西方世界的经典人》并担任1974年第十五版《大英百科全书》的编辑而闻名于世查尔斯·范多伦（1926－）曾任美国哥伦比亚大学教授，后因故离任，和艾德勒一起工作，一方面襄助艾德勒编辑《大英百科全书》，一方面将本书1940年初版内容大幅度增补改写。因此，本书1970年新版由两人共同署名 NO.1偶然逛书店时看到这本书，觉得书名挺有趣，随手翻看了一下，其中作者说到大部分的读者的阅读水平只是停留在小学六年级，我感觉自己被说中了，上网搜了下书评，发现好评不少，也发现我们现在所做的事也就是读书如果从源头的方法就不对，势必会事倍功半，所以就借了这本书，现在已经归还了，我还是想和大家分享一下书中作者对于读书的看法及我自身的看法 苏轼曾说：”三日不读书，则义理不交于胸中，对镜觉面目可憎，向人亦语言无味“,可见读书的重要性。对于我们做技术的更是如此，这让我突然想起刚刚工作时的一个事，当时我还是一个实习生，每个月我需要向部门的总经理汇报我这个月的工作情况，当我第一个月汇报时，我自信的说到我这个月技术水平进步很大，他却说不要沾沾自喜，不要光顾着技术提升，多注意思想上的提升，我当时还不怎么明白。随着工作经验的增加和不断自我学习，才意识到很多时候很多技术问题不是靠技术就能解决，比如有时你快速换个角度去思考问题就会豁然开朗，而别人还在死钻牛角尖，这就是思想的提升。就想很多武侠剧里有些武功高强的人还想要继续更强，却发现自己已经到了一个瓶颈，很难再有提升，这时候就需要突破自己的境界（比如打通了任督二脉），读书便是提升思想的最好方式，思想的提升便是个人的境界提升。 书中对阅读艺术下了个定义：”这是一个凭借着头脑运作，除了玩味读物中的一些字句之外，不假任何外助，以一己之力来提升自我的过程。”刚开始看书前面的文字，还不是特别有感觉，但是看到这句话，脑子里灵光一现，觉得这就是我心里的那个完美定义“。 读书不是一朝一夕的差事，而是一种应当一生去追求，去秉持的习惯。然而读书不是认字，不是图个热闹，懂得如何去读书当是养成这个习惯最重要的事情。这本《如何阅读一本书》看来好笑，可能大多数人看到都会觉得它近乎废纸，心中想着”我连读书都不会吗？”其实不然，读懂一本书还真的没那么就简单，书中说有许多人看书仅仅是打发时间，甚至看完就忘，”这样的人不值得羡慕，而应当同情“.这话看似冷酷，其实正是对读书而不得其法的我们最深刻的诠释。 它将阅读分做四个层次基础阅读、检视阅读、分析阅读、主题阅读。这四个层次是渐进掌握的，上一层次包括下一层次方法。第一层次基础阅读，其实就是最简单的对句子的理解，只要识字即可，对读者要求并不是很高，同时所收获到东东西也是最少的 以前资源有限，古人看书尚需”手自笔录“,前辈看书也许四处淘选，而如今我们想要看书几乎是随手可得。现在不会有人再去以读书作为消遣，更多的是为了提升自己，与别人的思想碰撞摩擦时可以有理有据而不是无理叫嚣，所以依我看来，读书的前提条件就是选择一本适合自己的书。我在看完这本《如何阅读一本书》后觉得自己最需要提升的就是这一点。我们总是被一些所谓”畅销书”的噱头所吸引，而并未检视它究竟是否适合自己。 “有些书可以浅尝辄止，有些书要生吞活剥，只有少数书要咀嚼与消化“ 在选择阅读内容时，要养成阅读目录的习惯。不要被书中文法或文章结构阻碍，不必要每词每句都读得透彻，重要的是在最少时间内掌握书的重点、主题框架等，再以此来判断一本书是否是自己想要阅读的书籍。 其次，现代人最需要的就是使自己浮躁的内心平静下来，主动地去翻阅一本适合自己的书，在检视后以全局的眼光思考它的脉络，将全书连贯起来，这使得你会沉浸在自己的脑海中，不仅仅收起了平时的浮躁，更能帮助你解开在分散阅读时的疑惑，同时这种新的视角将会带给你一些原先意想不到的新的感悟，这也正是分析阅读的价值所在。 最后，所谓的主题阅读，按我的理解要建立在一定的阅读量上才能做到。换句话说，这个层次教我们的是在阅读了很多书而又理不清他们之间关系的时候，如何去系统的理解，辩证的分析，最终学以致用。在做主题阅读时，要在脑中同时思考多本书中类似的内容，无论观点是相同的还是矛盾的，都要用自己的判断力和价值观把它们变成自己的东西。我认为，这一层次才是将书本上的东西或用起来的关键。 作者鼓励主动阅读，”阅读越主动，效果越好“.当一个人主动去读一本书，他在读书的时候就会很用心，对于有启发的地方还会拿笔画出来，读完之后还会思考书中的内容，就像海绵吸水一样真正吸收了书里的内容。我一直认为，单纯为了获得资讯而阅读”,并不能真正提升我们的理解力，只有我们将读书目标锁定在”为增进理解而阅读”时，去读一些”烧脑”的书，理解力才能真正得到提升 当然，读完下来。觉得这是一本很好的应用指导类书籍。好的阅读即主动的阅读不只是对阅读本身有用，也不只对工作或事业有帮助，它更能帮助我们的心智保持活力与成长，这样的成长对于一生来说都是财富。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程之ThreadLocal、Volatile、Synchronized、Atomic关键字]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadLocal%E3%80%81Volatile%E3%80%81synchronized%E3%80%81Atomic%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content type="text"><![CDATA[前言工作中用到ThreadLocal、Volatile、Synchronized、Atomic这四个关键字，是时候对它们总结一波了。 共享对象使用Java编写线程安全的程序关键在于正确的使用共享对象，以及安全的对其进行访问管理。Java的内置锁可以保障线程安全，对于其他的应用来说并发的安全性是使用内置锁保障了线程变量使用的边界。谈到线程的边界问题，随之而来的是Java内存模型另外的一个重要的含义，可见性。Java对可见性提供的原生支持是volatile关键字。 Atomic作用对于原子操作类，Java的concurrent并发包中主要为我们提供了这么几个常用的：AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference。对于原子操作类，最大的特点是在多线程并发操作同一个资源的情况下，使用Lock-Free算法来替代锁，这样开销小、速度快，对于原子操作类是采用原子操作指令实现的，从而可以保证操作的原子性。通常情况下，在Java里面，++i或者–i不是线程安全的，这里面有三个独立的操作：获得变量当前值，为该值+1/-1，然后写回新的值。在没有额外资源可以利用的情况下，只能使用加锁才能保证读-改-写这三个操作是“原子性”的。Java 5新增了AtomicInteger类，该类包含方法getAndIncrement()以及getAndDecrement()，这两个方法实现了原子加以及原子减操作，但是比较不同的是这两个操作没有使用任何加锁机制，属于无锁操作。它会在这步操作都完成情况下才允许其它线程再对它进行操作，而这个实现则是通过Lock-Free+原子操作指令来确定的AtomicInteger类中： 12345678public final int incrementAndGet() &#123; for (;;) &#123; int current = get(); int next = current + 1; if (compareAndSet(current, next)) return next; &#125; &#125; 123public final int get() &#123; return value; &#125; 1private volatile int value; 123public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; 可以看到是一个cas原子操作。unsafe是java用来在CPU级别的操作CAS指令的类，对于程序员来说，此类是不可用。由于是cpu级别的指令，其开销比需要操作系统参与的锁的开销小。对于多个线程进入时，会先比较现在的value 是否与expect相等，如果不相等，则进入下一个循环。如果相等，则会更新成update值。之后再进入的线程则会死循环。这样就保证了操作的原子性。这样一个方法中 即包含了原子性，又包含了可见性 而关于Lock-Free算法，则是一种新的策略替代锁来保证资源在并发时的完整性的，Lock-Free的实现有三步： 循环（for(;;)、while） CAS（CompareAndSet） 回退（return、break） 用法比如在多个线程操作一个count变量的情况下，则可以把count定义为AtomicInteger，如下：12345678public class Counter &#123; private AtomicInteger count = new AtomicInteger(); public int getCount() &#123; return count.get(); &#125; public void increment() &#123; count.incrementAndGet(); &#125; 在每个线程中通过increment()来对count进行计数增加的操作，或者其它一些操作。这样每个线程访问到的将是安全、完整的count。 内部实现采用Lock-Free算法替代锁+原子操作指令实现并发情况下资源的安全、完整、一致性 Volatile作用Volatile可以看做是一个轻量级的synchronized，它可以在多线程并发的情况下保证变量的“可见性”，什么是可见性？就是在一个线程的工作内存中修改了该变量的值，该变量的值立即能回显到主内存中，从而保证所有的线程看到这个变量的值是一致的，其二 volatile 禁止了指令重排，所以在处理同步问题上它大显作用，而且它的开销比synchronized小、使用成本更低。虽然 volatile 变量具有可见性和禁止指令重排序，但是并不能说 volatile 变量能确保并发安全。 举个栗子：在写单例模式中，除了用静态内部类外，还有一种写法也非常受欢迎，就是Volatile+DCL： 12345678910111213141516public class Singleton &#123; private static volatile Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 这样单例不管在哪个线程中创建的，所有线程都是共享这个单例的。虽说这个Volatile关键字可以解决多线程环境下的同步问题，不过这也是相对的，因为它不具有操作的原子性，也就是它不适合在对该变量的写操作依赖于变量本身自己。举个最简单的栗子：在进行计数操作时count++，实际是count=count+1;，count最终的值依赖于它本身的值。所以使用volatile修饰的变量在进行这么一系列的操作的时候，就有并发的问题 . volatile只能确保操作的是同一块内存，并不能保证操作的原子性。所以volatile一般用于声明简单类型变量，使得这些变量具有原子性，即一些简单的赋值与返回操作将被确保不中断。但是当该变量的值由自身的上一个决定时，volatile的作用就将失效，这是由volatile关键字的性质所决定的。所以在volatile时一定要谨慎，千万不要以为用volatile修饰后该变量的所有操作都是原子操作，不再需要synchronized关键字了。 用法因为volatile不具有操作的原子性，所以如果用volatile修饰的变量在进行依赖于它自身的操作时，就有并发问题，如：count，像下面这样写在并发环境中是达不到任何效果的：12345678910public class Counter &#123; private volatile int count; public int getCount()&#123; return count; &#125; public void increment()&#123; count++; &#125;&#125; 而要想count能在并发环境中保持数据的一致性，则可以在increment()中加synchronized同步锁修饰，改进后的为：12345678910public class Counter &#123; private volatile/无 int count; public int getCount()&#123; return count; &#125; public synchronized void increment()&#123; count++; &#125;&#125; 内部实现汇编指令实现 Synchronized作用synchronized关键字是Java利用锁的机制自动实现的，一般有同步方法和同步代码块两种使用方式。Java中所有的对象都自动含有单一的锁(也称为监视器)，当在对象上调用其任意的synchronized方法时，此对象被加锁(一个任务可以多次获得对象的锁，计数会递增)，同时在线程从该方法返回之前，该对象内其他所有要调用类中被标记为synchronized的方法的线程都会被阻塞。当然针对每个类也有一个锁(作为类的Class对象的一部分)，所以你懂的^.^。正因为它基于这种阻塞的策略，所以它的性能不太好，但是由于操作上的优势，只需要简单的声明一下即可，而且被它声明的代码块也是具有操作的原子性。最后需要注意的是synchronized是同步机制中最安全的一种方式，其他的任何方式都是有风险的，当然付出的代价也是最大的。 用法12345678public synchronized void increment()&#123; count++;&#125;public void increment()&#123; synchronized (Counte.class)&#123; count++; &#125;&#125; 内部实现重入锁ReentrantLock+一个Condition，所以是Lock的简化版本，因为一个Lock往往可以对应多个Condition ThreadLocal作用而ThreadLocal的设计，并不是解决资源共享的问题，而是用来提供线程内的局部变量，这样每个线程都自己管理自己的局部变量，别的线程操作的数据不会对我产生影响，互不影响，所以不存在解决资源共享这么一说，如果是解决资源共享，那么其它线程操作的结果必然我需要获取到，而ThreadLocal则是自己管理自己的，相当于封装在Thread内部了，供线程自己管理，这样做其实就是以空间换时间的方式(与synchronized相反)，以耗费内存为代价，单大大减少了线程同步(如synchronized)所带来性能消耗以及减少了线程并发控制的复杂度。 用法ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文一般使用ThreadLocal，官方建议我们定义为private static ，至于为什么要定义成静态的，这和内存泄露有关，后面再讨论。它有三个暴露的方法，set、get、remove。 123456789101112131415161718192021222324252627282930public class TestThreadLocal &#123; private static final ThreadLocal&lt;Integer&gt; value = new ThreadLocal&lt;Integer&gt;() &#123; @Override protected Integer initialValue() &#123; return 0; &#125; &#125;; public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; new Thread(new MyThread(i)).start(); &#125; &#125; static class MyThread implements Runnable &#123; private int index; public MyThread(int index) &#123; this.index = index; &#125; public void run() &#123; System.out.println("线程" + index + "的初始value:" + value.get()); for (int i = 0; i &lt; 10; i++) &#123; value.set(value.get() + i); &#125; System.out.println("线程" + index + "的累加value:" + value.get()); &#125; &#125;&#125; 运行结果如下，这些ThreadLocal变量属于线程内部管理的，互不影响： 线程0的初始value:0线程3的初始value:0线程2的初始value:0线程2的累加value:45线程1的初始value:0线程3的累加value:45线程0的累加value:45线程1的累加value:45线程4的初始value:0线程4的累加value:45 对于get方法，在ThreadLocal没有set值得情况下，默认返回null，所有如果要有一个初始值我们可以重写initialValue()方法，在没有set值得情况下调用get则返回初始值。 内部实现ThreadLocal内部有一个静态类ThreadLocalMap，使用到ThreadLocal的线程会与ThreadLocalMap绑定，维护着这个Map对象，而这个ThreadLocalMap的作用是映射当前ThreadLocal对应的值，它key为当前ThreadLocal的弱引用：WeakReference 内存泄露问题对于ThreadLocal，一直涉及到内存的泄露问题，即当该线程不需要再操作某个ThreadLocal内的值时，应该手动的remove掉，为什么呢？我们来看看ThreadLocal与Thread的联系图：此图来自网络： 其中虚线表示弱引用，从该图可以看出，一个Thread维持着一个ThreadLocalMap对象，而该Map对象的key又由提供该value的ThreadLocal对象弱引用提供，所以这就有这种情况：如果ThreadLocal不设为static的，由于Thread的生命周期不可预知，这就导致了当系统gc时将会回收它，而ThreadLocal对象被回收了，此时它对应key必定为null，这就导致了该key对应得value拿不出来了，而value之前被Thread所引用，所以就存在key为null、value存在强引用导致这个Entry回收不了，从而导致内存泄露。 所以避免内存泄露的方法，是对于ThreadLocal要设为static静态的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。除了这个，还必须在线程不使用它的值是手动remove掉该ThreadLocal的值，这样Entry就能够在系统gc的时候正常回收，而关于ThreadLocalMap的回收，会在当前Thread销毁之后进行回收。 但需要注意的是，虽然ThreadLocal和Synchonized都用于解决多线程并发访问，ThreadLocal与synchronized还是有本质的区别。synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享。即Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。所以ThreadLocal并不能代替synchronized，Synchronized的功能范围更广(同步机制)。 总结关于Volatile关键字具有可见性，但不具有操作的原子性，而synchronized比volatile对资源的消耗稍微大点，但可以保证变量操作的原子性，保证变量的一致性，最佳实践则是二者结合一起使用。 对于synchronized的出现，是解决多线程资源共享的问题，同步机制采用了“以时间换空间”的方式：访问串行化，对象共享化。同步机制是提供一份变量，让所有线程都可以访问。 对于Atomic的出现，是通过原子操作指令+Lock-Free完成，从而实现非阻塞式的并发问题。 对于Volatile，为多线程资源共享问题解决了部分需求，在非依赖自身的操作的情况下，对变量的改变将对任何线程可见。 ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 参考: http://blog.csdn.net/z69183787/article/details/51490129]]></content>
      <categories>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目地址汇总]]></title>
    <url>%2F%E9%A1%B9%E7%9B%AE%E5%9C%B0%E5%9D%80%2F%E9%A1%B9%E7%9B%AE%E5%9C%B0%E5%9D%80%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[地址汇总如下 有样青年社区 ：www.youyoung.cc 海绵学院：sponge.qugeming.com]]></content>
      <categories>
        <category>项目地址</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>地址</tag>
      </tags>
  </entry>
</search>
